好的,下面是使用 pytest 框架编写的测试代码:

```python
##File: /Users/allwefantasy/projects/byzer-llm/tests/test_prompt.py
import pytest
import byzerllm

@pytest.fixture(scope="module")
def setup():
    byzerllm.connect_cluster()
    llm = byzerllm.ByzerLLM()
    model = "qianwen_chat"
    llm.setup_default_model_name(model)
    llm.setup_template(model,"auto")
    return llm

class Wow:
    def __init__(self,llm):
        self.llm = llm

    @byzerllm.prompt(lambda self:self.llm)
    def test(self,s:str)->str: 
        '''
        Hello, {{ s }}!
        '''

    @byzerllm.prompt()
    def test2(self,s:str)->str: 
        '''
        Hello, {{ s }}!
        '''    

@byzerllm.prompt(options={"llm_config":{}})
def test(s:str)->str: 
    '''
    Hello, {{ s }}!
    '''  

def test_prompt_class_method(setup):
    w = Wow(setup)
    assert w.test.prompt("你是谁") == "Hello, 你是谁!"
    assert "你是谁" in w.test.run("你是谁")

def test_prompt_class_method_no_llm(setup):    
    w = Wow(setup)
    assert w.test2.prompt("你是谁") == "Hello, 你是谁!"
    
def test_prompt_standalone_func(setup):
    test.with_llm(setup)
    assert test.prompt("你是谁") == "Hello, 你是谁!"
    assert "你是谁" in test.run("你是谁")
    
def test_prompt_options(setup):
    w = Wow(setup)    
    result = w.test.options({"model":"kimi_8k_chat","llm_config":{"max_length":1000}}).run("你是谁")
    assert "你是谁" in result
    assert len(result) <= 1000
    
def test_prompt_with_llm(setup):
    w = Wow(setup)
    assert "你是谁" in w.test.with_llm(setup).run("你是谁")
```

这里使用了 pytest 的几个特性:

1. 使用 @pytest.fixture 定义了一个名为 setup 的 fixture,它在模块级别共享。在这个 fixture 中,我们建立了到 Ray 集群的连接,创建了 ByzerLLM 实例,并设置了默认的模型和模板。

2. 将测试用例拆分为多个独立的函数,每个函数测试一个特定的场景。pytest 会自动发现并执行这些测试函数。

3. 测试函数接受 setup fixture 作为参数,从而可以访问在 fixture 中创建的 ByzerLLM 实例。

4. 使用 assert 语句来验证 prompt 方法生成的 prompt 字符串是否符合预期,以及 run 方法返回的结果中是否包含输入的字符串。

使用 pytest,我们可以更好地组织和管理测试用例。通过将设置逻辑移到 fixture 中,可以避免在每个测试函数中重复编写设置代码。此外,pytest 还提供了丰富的断言函数和插件机制,使测试更加灵活和可扩展。

你可以将这个测试文件保存为 test_prompt.py,并将其放在项目的 tests 目录下。然后,在项目根目录下运行 pytest 命令即可执行所有的测试用例。